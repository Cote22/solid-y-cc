# Gestión de Errores

- El código debe ser limpio, pero también robusto.
- La gestión de errores puede ensuciar mucho el código, por lo que hay que prestarle especial atención.

- Devolver excepciones en lugar de códigos de error.
- Usar excepciones unchecked
- No devolver ni pasar null.


* La gestión de errores es una parte fundamental.

- Un buen software debe ser robusto, debe tratar bien todos los errores que puedan aparecer.

- Lo malo es que si no, si no se hace con especial cuidado, esta gestión de errores puede ensuciar mucho el código.


### Excepciones en lugar de codigo de error

```
// Ejemplo del libro Clean Code, de Robert C Martin

public class DeviceController {

    public void sendShutDown () {
        DeviceHandle handle = getHandle(DEV1);
        // Check the state of the device
        if(handle != DeviceHandle. INVALID) {
            // Save the device status to the record field
            DeviceRecord record = retrieveDeviceRecord (handle);
            // If not suspend, shut down
            if (record.getStatus () != DEVICE_SUSPENDED) {
                pauseDevice (handle);
                clearDeviceWorkQueue (handle);
                closeDevice (handle);
            }else {
                logger.log ("Device suspended. Unable to shut down");
            }
        }else {
            logger. log("Invalid handle for: " + DEV1.toString());
        }
    }
}
```

Usando excepciones no tienes por qué tratar el error en el momento.

El problema de implementar esta función de esta forma, la forma que acabamos de ver es que los errores se tienen que tratar al momento, quedando el código lleno de infelices que no dejan claro cuál es el camino correcto de ejecución.

Esta función se podría refactorizar de esta forma.

```
public void sendShutDown () {
    try {
        tryToShutDown ();
    } catch (DeviceShutDownError e) {
        logger.log(e);
    }
}

private void tryToShutDown() throws DeviceShutDownError {
    DeviceHandle handle = getHandle(DEV1); // Throws DeviceShutDownError
    DeviceRecord record = retrieveDeviceRecord (handle);
    pauseDevice (handle) ;
    clearDeviceWorkQueue (handle);
    closeDevice(handle);
}
```

Recordar que es importante tener el try Catch separado en una función para tener ambas ambas funciones, trabajando sobre un único nivel de abstracción.

### Unchecked Exceptions

- Se trata de excepciones que heredan de RuntimeException. Ejemplo, la NullPointerException.
- Se pueden tratar con try-catch, pero no es estrictamente necesario. 
- Las excepciones checked, son las excepciones "normales", heredan de
- Exception. Si no las tratas el programa no compila.
- Recomendado usar checked Exceptions si se trata de una librería crítica, que sea de obligado cumplimiento tratar las excepciones.

```
public class Driver {
    public void startDriving() {
        try {
            car.start();
        } catch (BatteryFailureException | EngineFailureException e) {
            logger. log("Could not start driving. Car failure: " + e);
        }
    } 

}

public class Car {
    public void start() throws BatteryFailureException, EngineFailureException {
        battery. connect(); 
        engine.start();
        ｝
    }
}       

public class Battery {
    public void connect() throws BatteryFailureException;
}  
            
public class Engine {
    public void start() throws EngineFailureException;
}
```

### No devolver Null

- NullPointerException es una unchecked exception.
- Muchos errores son debido a devolver null y no tratarlo correctamente.

```
public void processRequestBatch () {
    List<Request> requestList = getRequestList();
        if(requestList != null) {
            for(Request r : requestList){
            processRequest (r);
        }
    }
}
```

```
public void processRequestBatch() {
    List<Request> requestList = getRequestList();
    for (Request r : requestList) {
        processRequest (r);
    }
}
```

Devolver null en una función implica dos problemas, el primero es que obligas al usuario de la función a hacer una comprobación del resultado, mirando que no sea null.

Si el usuario no realiza esta comprobación y la función devuelve null, se puede dar una null pointer exception haciendo que el programa rompa.

Se ensucias demasiado el código y tienes que comprobar en todas las funciones de tu programa que los parámetros no sean null.


### No pasar Null

```
public Point getMiddlePoint(Point a, Point b) {
    if(a != null && b != null) {
        Double resultPointX = (a.getX() - b.getX()) / 2;
        Double resultPointY = (a.getY() - b.getY()) / 2;

        return newpoint(resultPointX, resultPointY);
    }

    // Return?
}
```



```
public Point getMiddlePoint (Point a, Point b) {
    Double resultPointX = (a.getX() - b.getX()) / 2;
    Double resultPointY = (a.getY() - b.getY()) / 2;
    return newPoint(resultPointX, resultPointY);
}
```

No hay una manera perfecta de tratar con el problema de la recepción de null en los parámetros de una función.

Tampoco debemos pasar null en los parámetros de la llamada a una función. Las razones son las mismas.
 - Por un lado, ensucias demasiado el código. Si tienes que comprobar en todas las funciones de tu programa que los parámetros no sean null.
 - Y por otra, te la estás jugando a que una función no haga comprobaciones de Nul y te dé un null pointer exception rompiendo el programa.

Por eso recomendamos nunca pasar null a una función.