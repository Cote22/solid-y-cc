# Funciones

### Caracteristicas de una buena función

Las funciones son las piezas de extracción mas pequeñas de tu codigo y es importante que sean claras, consisas, faciles de leer y faciles de modificar.

Las caracteristicas de las funciones son las siguientes

- Pequeñas, muy pequeñas
- Hacen una sola cosa
- Nivel de abstracción unico.
- Reciben pocos argumentos
- No tienen secundarios
- Devuelven excepciones en lugar de codigo de error

Public Boolean shouldWrite100line 
    Functions() {
    Return false;
}

### Las funciones hace una cosa.

Es un principio fundamental de que las funciones hagan solo una cosa.

En el ejemplo podemos ver una función llamada readNumbersFromFileAndCalculateTotal, que recibe un file web de fichero y devuelve un entero.

En primer lugar, podemos ver claramente que hace dos cosas.

Primero, lee todas las lineas del fichero de la web file que le pasamos y las guarda en la lista de Numbers y segundo lugar, lo que hace es iterar esa lista de Numbers e ir acumulando el valor en la variable total y devolverla. Esto es una violacion clara de este principio, ya que esta haciendo dos cosas en lugar de una.

Ejemplo:

public Interger readNumbersFromFileAndCalculateTotal(String fileURL){
    List<String> numbers =
            Files.readAllLines(PAths.get(fileURL), StandardCharsets.UTF_8);

    Interger total = 0;
    for (String numberString : numbers) {
        total += Interger.valueof(numberString);
    }

    return total;
}

La función anterior se puede refactorizar de la siguiente forma:

public Interger getMonthlySales() {
    List<String> sales = readNumbersFromFile(MONTHLY_SALES_FILE_PATH);
    return calculateSumamatory(sales);
}

public List<String> readNumbersFromFileAndCalculateTotal(String fileURL){
    return Files.readAllLines(PAths.get(fileURL), StandardCharsets.UTF_8);
}

public Interger calculateSummatory(List<String> values) {
    Interger total = 0;
    for (String numberString : numbers) {
        total += Interger.valueof(numberString);
    }

    return total;
}

Tenemos la función getMontlySales toma las ventas del mes que devuelve un entero con el numero total de ventas para ese mes

Esa función en la primera linea llama a otra funcion llamada readNumbersFromFile recibe la URL del fichero y devuelve una lista de strings con todas las lineas del fichero que se le pase.

Volviendo a las funcion principal, podemos ver que se llama una tercera funcion CalculateSumatory pasandole como argumento la lista de string con las ventas diarias del mes.

Esta funcion esta declarada inmediatamente despues de recibir la lista de string con los valores que se quieren sumas y devuelven un entero con el valor total.

Lo unico que se hace es iterar sobre la lista, acumulando los resultados en la variable total y se devuelve al final.
De esta forma el codigo queda mucho mas legible y se puede leer el codigo secuencialmente entrando a la funcion principal


### Un unico nivel Abstracción

Un concepto que hay que tener claro a la hora de crear buenas funciones y buen software son los niveles de abstracción.

En el ejemplo podemos ver la clase persona tiene una función conducir un coche.

Para conducir lo que tiene que hacer es abrir la puerta, seleccionarse como conductor principal, tomar la bateria, conectarla, tomar el motor y encenderlo.

Pero algo no cuadra aquí. En esta función se están tratando dos niveles de abstracción totalmente distintos.

Este está a un nivel que es abrir la puerta y seleccionarse como chofer, es decir, sentarse en el coche y hay otro nivel que no pertenece al ámbito de esta función, que es conectar la batería y encender el motor. Esto debería ir en otra función separada, de hecho debería ir en el coche porque es el que tiene que saber cómo encender todos sus mecanismos.

En este ejemplo tenemos el código refactorizado. Por un lado tenemos abajo la función persona, que tiene lo mismo abrir la puerta y seleccionarse como conductor. Pero en lugar de encender la batería y encender el motor, lo que hace es encender el coche en el mismo nivel de abstracción que los otros.


public class Person {
    public void drive(Car car) {
        car.OpenDoor();
        car.setDriver(this);
        car.getBattery(). connect();
        car.getEngine().start();
    }
}

Por otro lado, arriba tenemos el coche, el cual tiene la batería y el motor y al llamar a la función start del coche, lo que hace el coche es conectar su batería y conectar su motor.
De esta forma tenemos los dos niveles de abstracción separados.

public class Car {
    Battery battery;
    Engine engine;

    public void start() {
        battery.connect();
        engine.start();
    }
}

public class Person {
    public void drive(Car car) {
        car.OpenDoor();
        car.setDriver(this);
        car.start();
    }
}




Aca utilizamos el mis ejemplo del principio de que cada función debe hacer una única cosa.

Esta función está a un nivel de abstracción superior a las otras dos.

Las funciones readNumbersFromFile y CalculateSumatory está en un nivel de abstracción más bajo porque realizan

acciones de más bajo nivel para leer los números de un fichero.

Separar los niveles de abstracción de esta forma es fundamental para construir codigo de calidad ordenado, legible.

En este ejemplo es bastante sencillo y es instuitivo, pero si el problema es muy grande, puede ser complicado identificar correctamente todos los niveles de abstracción.

### Pocos Argumentos

- Se deben evitar las funciones con mas de 3 argumentos.
- Un gran numero de argumentos suele indicar una mala encapsulación

Los buenas funciones reciben pocos argumentos, la mejor función es la que recibe ningun argumento.

### Excepciones en lugar de codigos de error

- Si devuelves códigos de error, debes tratarlo al momento, con excepciones no.

public void restoreLastDatabaseBackup () {
    if(backupCurrentData () == 0K) {
        Backup backup = getLastBackup();
        if(backup.restore() == 0K) {
            Logger.log("Backup restored");
        }else {
            Logger.log("Error restoring backup")
        ｝
    }else {
        Logger.log("Could not backup current data. Restore backup canceled.")
    }
  }
}

- Utilizar excepciones te permite tener el camino de ejecución correcto separado del camino de errores.

public void safelyRestoreLastDatabaseBackup() {
    try {
        backupCurrentData (); // Throws CreateBackupException
        Backup backup = getLastBackup() ;
        backup. restore();   //Throws RestoreBackupException
        Logger. log ("Backup restored");
    } catch (CreateBackupException e) {
        Logger.log ("Could not backup current data. Restore backup canceled.")
    } catch (RestoreBackupException e) {
        Logger.log("Error restoring backup")
    }
}

- Lo ideal sería separar también los try-catch en una función.

public void safelyRestoreLastDatabaseBackup() {
    try {
        restoreLastDatabaseBackup();
    } catch (CreateBackupException e) {
        Logger.log("Could not backup current data. Restore backup canceled.")
    } catch (RestoreBackupException e) {
        Logger. log("Error restoring backup")
    }
}

private void restoreLastDatabaseBackup() throws CreateBackupException, RestoreBackupException {
    backupCurrentData();
    Backup backup = getLastBackup();
    backup.restore();
}

